// Importa√ß√µes necess√°rias
import { drizzle } from 'drizzle-orm/neon-serverless';
import { neon, neonConfig } from '@neondatabase/serverless';
import { sql } from 'drizzle-orm';
import * as schema from '../shared/schema';
import { log } from './vite';
import pkg from 'pg';
import ws from 'ws';
const { Pool } = pkg;

// Configurar websocket para Neon
neonConfig.webSocketConstructor = ws;

// Vari√°vel para armazenar a inst√¢ncia do banco de dados
let db: any;

// Fun√ß√£o para detectar o tipo de conex√£o (Neon vs PostgreSQL padr√£o)
function isNeonConnection(url: string): boolean {
  return url.includes('neon') || url.startsWith('postgres://db.') || url.includes('.neon.tech');
}

// Fun√ß√£o para inicializar o banco de dados
function initDatabase() {
  try {
    const connectionString = process.env.DATABASE_URL;
    
    if (!connectionString) {
      log('‚ö†Ô∏è Vari√°vel DATABASE_URL n√£o definida', 'error');
      throw new Error('DATABASE_URL n√£o definida');
    }
    
    // Usar apenas Neon com o cliente HTTP - mais compat√≠vel
    log('üåê Usando conex√£o Neon Serverless');
    
    try {
      // Usar o cliente Neon com WebSocket e HTTP fallback
      // Para resolver o erro "client.query is not a function"
      const sqlClient = neon(connectionString, { fullResults: true });
      
      // Criar a inst√¢ncia do Drizzle ORM
      db = drizzle(sqlClient, { schema });
      
      // Validar que o cliente est√° realmente funcional
      // executando uma query de teste
      (async () => {
        try {
          const result = await db.execute(sql`SELECT 1 AS test_connection`);
          log('üîå Conex√£o de teste bem-sucedida!');
        } catch (testError) {
          log(`‚ùå Erro no teste de conex√£o: ${testError}`, 'error');
        }
      })();
      
      log('‚úÖ Banco de dados inicializado com Neon');
      return true;
    } catch (error) {
      log(`‚ùå Erro ao inicializar banco de dados: ${error}`, 'error');
      return false;
    }
  } catch (error) {
    log(`‚ùå Erro ao inicializar banco de dados: ${error}`, 'error');
    return false;
  }
}

// Tentar inicializar o banco de dados na importa√ß√£o
try {
  initDatabase();
} catch (error) {
  log(`‚ùå Falha ao conectar ao banco de dados: ${error}`, 'error');
}

/**
 * Testa a conex√£o com o banco de dados
 */
export async function testConnection() {
  try {
    if (!db) {
      log('‚ùå Cliente de banco de dados n√£o inicializado', 'error');
      return false;
    }
    
    // Tenta executar uma query simples para verificar a conex√£o
    try {
      // Usando uma consulta SQL b√°sica que funciona com qualquer provedor
      const testResult = await db.execute(sql`SELECT 1 AS test_value`);
      log('üîå Conex√£o com o banco de dados estabelecida com sucesso');
      
      // M√©todo espec√≠fico para criar as tabelas se elas n√£o existirem
      try {
        // Este c√≥digo ser√° executado apenas uma vez durante a inicializa√ß√£o
        // e garantir√° que as tabelas existam conforme definido no schema.
        log('üîÑ Verificando se o schema est√° criado...');
        
        // Tentar fazer uma consulta simples para verificar
        try {
          const configExists = await db.execute(sql`
            SELECT EXISTS (
              SELECT FROM information_schema.tables 
              WHERE table_name = 'system_config'
            ) as exists
          `);
          
          // Se chegou aqui, a conex√£o est√° OK
          log('‚úÖ Conex√£o verificada e schema existe');
          
          // Agora tenta encontrar configura√ß√µes
          try {
            const configResult = await db.select().from(schema.systemConfig).limit(1);
            log(`Configura√ß√µes encontradas: ${configResult.length}`);
          } catch (schemaError) {
            log(`‚ö†Ô∏è Aviso: Erro ao buscar configura√ß√µes. ${schemaError}`, 'warn');
          }
        } catch (schemaCheckError) {
          log(`‚ö†Ô∏è Aviso: N√£o foi poss√≠vel verificar schema. ${schemaCheckError}`, 'warn');
        }
      } catch (schemaError) {
        log(`‚ö†Ô∏è Aviso: Tabelas podem n√£o existir ainda. ${schemaError}`, 'warn');
        // N√£o falha aqui pois a conex√£o est√° OK, s√≥ o schema que pode n√£o estar pronto
      }
      
      return true;
    } catch (error) {
      log(`‚ùå Erro ao testar banco de dados: ${error}`, 'error');
      return false;
    }
  } catch (error) {
    log(`‚ùå Erro ao testar conex√£o com o banco de dados: ${error}`, 'error');
    return false;
  }
}

/**
 * Configura o banco de dados para uso
 */
export async function setupDatabase() {
  try {
    const connected = await testConnection();
    if (!connected) {
      return false;
    }
    
    // Verificar se existe uma configura√ß√£o do sistema
    const configs = await db.select().from(schema.systemConfig).limit(1);
    
    if (configs.length === 0) {
      // Criar configura√ß√£o inicial
      await db.insert(schema.systemConfig).values({
        execution_mode: 'local',
        local_llm_url: 'http://127.0.0.1:11434',
        cloud_llm_url: 'https://oracle-api.carlosdev.app.br',
        base_prompt: 'Voc√™ √© um assistente √∫til e profissional que responde de maneira concisa e clara.',
        logs_enabled: true,
        active_llm_url: 'http://127.0.0.1:11434'
      });
      
      log('‚úÖ Configura√ß√£o inicial criada com sucesso');
    }
    
    log('‚úÖ Banco de dados configurado com sucesso');
    return true;
  } catch (error) {
    log(`‚ùå Erro ao configurar banco de dados: ${error}`, 'error');
    return false;
  }
}

// Exportar a inst√¢ncia do banco de dados para uso em outros m√≥dulos
export { db };